import os
import xml.etree.ElementTree as ET
from JackTokenizer import Tokenizer, get_xml_file_path, get_jack_files, make_xml_directory

class CompileEngine:
    '''Effects the actual compilation output. Gets its input from a
    JackTokenizer and emits its parsed structure into an output file/stream. The
    output is generated by a series of compilexxx() routines, one for every syntactic
    element xxx of the Jack grammar'''

    def __init__(self, tokenizer: Tokenizer):
        self.tokenizer = tokenizer
        self.ops = {
            '+', '-', '*', '/', '&', '|', '<', '>', '='
        }

    def next_token(self):
        '''Get next token, None if no next token'''
        
        if not self.tokenizer.has_more_tokens(): return

        self.tokenizer.advance()
        return self.tokenizer.current_token
    
    def peek_at_next_token(self, n = 0):
        '''Returns next token'''

        if not self.tokenizer.has_more_tokens(): return

        next_tokens = self.tokenizer.next_tokens

        if (len(next_tokens) < n + 1): return
        return next_tokens[n]
    
    @staticmethod
    def create_sub_element(root, type, text = None):
        element = ET.SubElement(root, type)
        if text:
            element.text = ' ' + text + ' '
        return element

    def add_terminal_element(self, root):
        token = self.next_token()
        self.create_sub_element(root, self.tokenizer.token_type(), token)

    def compile_class(self):
        '''Returns parse tree for everything in class, class: 'class' className '{' classVarDec* subroutineDec* '}' '''
        # Class structure
        class_root = ET.Element('class')

        # Class keyword
        self.add_terminal_element(class_root)
        # Class name identifier
        self.add_terminal_element(class_root)
        # { symbol
        self.add_terminal_element(class_root)

        # Create class var decs if there are any
        while self.peek_at_next_token() in ['static', 'field']:
            self.compile_class_var_dec(class_root)
        
        # Create subroutines if there are any
        while self.peek_at_next_token() in ['constructor', 'function', 'method']:
            self.compile_subroutine(class_root)

        # } symbol
        self.add_terminal_element(class_root)

        return class_root

    def compile_class_var_dec(self, root):
        '''classVarDec: ('static'|'field') type varName (',' varName)* ';' '''
        # Class var dec
        class_var_dec_root = self.create_sub_element(root, 'class_var_dec')

        # Static or field keyword
        self.add_terminal_element(class_var_dec_root)
        # Type keyword
        self.add_terminal_element(class_var_dec_root)

        # Add name(s) until semicolon: (',' varName)*
        while self.peek_at_next_token() != ';':
            self.add_terminal_element(class_var_dec_root)
        # ; symbol
        self.add_terminal_element(class_var_dec_root)

    def compile_subroutine(self, root):
        '''subroutineDec: ('constructor'|'function'|'method')
        ('void' | type) subroutineName '(' parameterList ')'
        subroutineBody. subroutineBody: '{' varDec* statements '}' '''
        # Subroutine dec structure
        subroutine_dec_root = self.create_sub_element(root, 'subroutine_dec')

        # Constructor or function or method keyword
        self.add_terminal_element(subroutine_dec_root)
        # Type keyword
        self.add_terminal_element(subroutine_dec_root)
        # Name identifier
        self.add_terminal_element(subroutine_dec_root)
        # ( symbol
        self.add_terminal_element(subroutine_dec_root)
        # Parameter list (only if there are any parameters)
        self.compile_parameter_list(subroutine_dec_root)
        # ) symbol
        self.add_terminal_element(subroutine_dec_root)

        # Subroutine body structure
        subroutine_body_root = self.create_sub_element(subroutine_dec_root, 'subroutine_body')

        # { symbol
        self.add_terminal_element(subroutine_body_root)

        # Add var decs if any
        while self.peek_at_next_token() == 'var':
            self.compile_var_dec(subroutine_body_root)
        
        # Add statements if any
        self.compile_statements(subroutine_body_root)
        
        # } symbol
        self.add_terminal_element(subroutine_body_root)

    def compile_parameter_list(self, root):
        '''parameterList: ((type varName) (',' type varName)*)'''
        # Create parameter_list
        parameter_list_root = self.create_sub_element(root, 'parameter_list')

        # Add all parameters
        while self.peek_at_next_token() != ')':
            self.add_terminal_element(parameter_list_root)
    
    def compile_var_dec(self, root):
        '''varDec: 'var' type varName (',' varName)* ';' '''
        # Create var_dec
        var_dec_root = self.create_sub_element(root, 'var_dec')

        # var keyword
        self.add_terminal_element(var_dec_root)
        # Type keyword
        self.add_terminal_element(var_dec_root)

        # Add name(s) until semicolon: (',' varName)*
        while self.peek_at_next_token() != ';':
            self.add_terminal_element(var_dec_root)
        # ; symbol
        self.add_terminal_element(var_dec_root)

    def compile_statements(self, root):
        '''statements: statement*
        statement: letStatement | ifStatement | whileStatement |
        doStatement | returnStatement'''
        # Create statements
        statements_root = self.create_sub_element(root, 'statements')

        # Add statements if any
        next_token = self.peek_at_next_token()
        while next_token != '}':
            # Find correct statement type
            if next_token == 'let':
                self.compile_let_statement(statements_root)
            elif next_token == 'if':
                self.compile_if_statement(statements_root)
            elif next_token == 'while':
                self.compile_while_statement(statements_root)
            elif next_token == 'do':
                self.compile_do_statement(statements_root)
            elif next_token == 'return':
                self.compile_return_statement(statements_root)
            
            next_token = self.peek_at_next_token()
        
    def compile_let_statement(self, root):
        '''letStatement: 'let' varName ('[' expression ']')? '=' expression ';' '''
        # Create let statement
        let_statement_root = self.create_sub_element(root, 'let_statement')

        # let keyword
        self.add_terminal_element(let_statement_root)
        # Var name identifier
        self.add_terminal_element(let_statement_root)
        
        # Add array index ([i]) if any
        if self.peek_at_next_token() == '[':
            # [ symbol
            self.add_terminal_element(let_statement_root)
            # Add expression
            self.compile_expression(let_statement_root)
            # ] symbol
            self.add_terminal_element(let_statement_root)
        
        # = symbol
        self.add_terminal_element(let_statement_root)

        # Add expressions
        self.compile_expression(let_statement_root)

        # ; symbol
        self.add_terminal_element(let_statement_root)
    
    def compile_if_statement(self, root):
        '''ifStatement: 'if' '(' expression ')' '{' statements '}' ('else' '{' statements '}')? '''
        # Create if statement
        if_statement_root = self.create_sub_element(root, 'if_statement')

        # if keyword
        self.add_terminal_element(if_statement_root)
        # ( symbol
        self.add_terminal_element(if_statement_root)

        # Add expression
        self.compile_expression(if_statement_root)

        # ) symbol
        self.add_terminal_element(if_statement_root)
        # { symbol
        self.add_terminal_element(if_statement_root)

        # Add statements
        self.compile_statements(if_statement_root)

        # } symbol
        self.add_terminal_element(if_statement_root)
        
        # Add else statement
        if self.peek_at_next_token() == 'else':
            self.add_terminal_element(if_statement_root)
            # { symbol
            self.add_terminal_element(if_statement_root)

            # Add statements
            self.compile_statements(if_statement_root)

            # } symbol
            self.add_terminal_element(if_statement_root)

    def compile_while_statement(self, root):
        '''whileStatement: 'while' '(' expression ')' '{' statements '}' '''
        # Create while statement
        while_statement_root = self.create_sub_element(root, 'while_statement')

        # while keyword
        self.add_terminal_element(while_statement_root)
        # ( symbol
        self.add_terminal_element(while_statement_root)

        # Add expression
        self.compile_expression(while_statement_root)

        # ) symbol
        self.add_terminal_element(while_statement_root)
        # { symbol
        self.add_terminal_element(while_statement_root)

        # Add statements
        self.compile_statements(while_statement_root)

        # } symbol
        self.add_terminal_element(while_statement_root)

    def compile_do_statement(self, root):
        '''doStatement: 'do' subroutineCall ';' '''
        # Create do statement
        do_statement_root = self.create_sub_element(root, 'do_statement')

        # do keyword
        self.add_terminal_element(do_statement_root)

        # Create subroutine call
        self.compile_subroutine_call(do_statement_root)
        
        # ; symbol
        self.add_terminal_element(do_statement_root)

    def compile_subroutine_call(self, root):
        '''subroutineCall: subroutineName '(' expressionList ')' | (className | varName) '.' subroutineName '(' expressionList ')' '''
        # Subroutine or class or var name
        self.add_terminal_element(root)

        # In case of class/var.func
        if self.peek_at_next_token() == '.':
            # . symbol
            self.add_terminal_element(root)
            # Subroutine name
            self.add_terminal_element(root)

        # ( symbol
        self.add_terminal_element(root)
        
        # Add expression list
        self.compile_expression_list(root)

        # ) symbol
        self.add_terminal_element(root)

    def compile_return_statement(self, root):
        '''ReturnStatement 'return' expression? ';' '''
        # Create return statement
        return_statement_root = self.create_sub_element(root, 'return_statement')

        # return keyword
        self.add_terminal_element(return_statement_root)

        # Add expression if any
        if self.peek_at_next_token() != ';':
            self.compile_expression(return_statement_root)

        # ; symbol
        self.add_terminal_element(return_statement_root)

    def compile_expression(self, root):
        '''expression: term (op term)* '''
        # Create expression
        expression_root = self.create_sub_element(root, 'expression')

        # Add term
        self.compile_term(expression_root)

        # Add (op term) pairs if any
        while self.peek_at_next_token() in self.ops:
            # Add op
            self.add_terminal_element(expression_root)

            # Add term
            self.compile_term(expression_root)
    
    def compile_term(self, root):
        '''term: integerConstant | stringConstant | keywordConstant |
        varName | varName '[' expression ']' | subroutineCall |
        '(' expression ')' | unaryOp term '''
        # Create term
        term_root = self.create_sub_element(root, 'term')

        next_token = self.peek_at_next_token()
        # Case 1: unary op term
        if next_token in ['-','~']:
            # Add unary op
            self.add_terminal_element(term_root)

            # Add term
            self.compile_term(term_root)
        # Case 2: (experssion)
        elif next_token == '(':
            # ( symbol
            self.add_terminal_element(term_root)

            # Add expression
            self.compile_expression(term_root)

            # ) symbol
            self.add_terminal_element(term_root)
        # Case 3: constant or var or var with index or subroutine call
        else:
            # Peek 2 ahead
            token = self.peek_at_next_token(1)

            # Subcase 1: constant or var with nothing after
            if not token:
                self.add_terminal_element(term_root)
            # Subcase 2: array var with index
            elif token == '[':
                # Var name
                self.add_terminal_element(term_root)

                # [ symbol
                self.add_terminal_element(term_root)

                # Add expression
                self.compile_expression(term_root)

                # ] symbol
                self.add_terminal_element(term_root)
            # Subcase 3: subroutine call
            elif token in ['(', '.']:
                self.compile_subroutine_call(term_root)
            # Subcase 4: all constants and vars
            else:
                self.add_terminal_element(term_root)

    def compile_expression_list(self, root):
        '''expressionList: (expression (',' expression)* )? '''
        # Create expression list
        expression_list_root = self.create_sub_element(root, 'expression_list')

        # Start with expression then add (, expression) if there are more than 1 expressions or any
        if (self.peek_at_next_token() != ')'):
            # Add expression
            self.compile_expression(expression_list_root)
        # Add , expressions
        while (self.peek_at_next_token() == ','):
            # , symbol
            self.add_terminal_element(expression_list_root)

            # Add expression
            self.compile_expression(expression_list_root)

def main(jack_file_path):

    # Find all jack files, and make directory to store xml files
    jack_files = get_jack_files(jack_file_path)
    make_xml_directory(jack_file_path)

    # Generate a xml file for each jack file
    xml_files = []
    for file_name in jack_files:

        # Create tokenizer for this jack file
        file_path = os.path.join(jack_file_path, file_name)
        tokenizer = Tokenizer(file_path)

        # Use compile enginer to preform recusrive parse descent starting from the garunteed single class in the jack file
        compile_engine = CompileEngine(tokenizer)
        root = compile_engine.compile_class()

        # Don't forget to close jack file
        tokenizer.jack_file.close()

        # Write tree to xml file
        xml_file_path = get_xml_file_path(jack_file_path, file_name, include_T = 0)
        xml_files.append(xml_file_path)
        tree = ET.ElementTree(root)
        tree.write(xml_file_path)

    print(f'{" ".join(jack_files)} parsed at {" ".join(xml_files)}')

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description="Parse Jack file")
    parser.add_argument('jack_file_path', type=str, help="The input Jack file")
    
    args = parser.parse_args()

    main(args.jack_file_path)
